## Eventstorming 생성 프롬프트 요약

아래 내용은 `eventstorming_agent/agent.py`에 정의된 LLM 프롬프트를 재구성한 것으로, 모델 생성 시 고려해야 할 흐름과 객체별 기준을 정리한 문서이다.

### 전체 생성 절차

1. **사용자 요구 분석**  
   - 시나리오를 읽고 모델링해야 할 도메인을 파악한다.

2. **Bounded Context 도출**  
   - 서비스/마이크로서비스 경계를 식별하고, 각 컨텍스트에 이름과 설명을 부여한다.

3. **서비스 상호작용 흐름 정리**  
   - 사용자 시나리오에 등장하는 모든 단계(예: “민원 안내 → 민원 조회 → 민원 신청 → …”)를 그대로 재현하며, 각 단계 사이의 호출 관계를 “Event → Handler” 형태로 명시한다.  
   - 특정 호출 결과에 따라 다음 단계가 달라지는 경우, 성공/실패 이벤트를 분리하여 흐름이 명확히 보이도록 한다.
   - “OO 컨텍스트에 ReadModel/Policy를 추가해줘”처럼 **명시적으로 지시된 컨텍스트**가 있다면, 기존 보드 데이터나 이미 정의한 컨텍스트 중 동일/유사 이름을 찾아 그 내부에 요청된 객체를 추가한다(새로운 서비스라고 분명히 언급된 경우에만 새 컨텍스트 생성).

4. **핵심 구성요소 정의**  
   - Aggregate, Command, Event, Policy(및 CQRS 시 ReadModel)를 컨텍스트 단위로 채운다(세부 기준은 아래 참고).

5. **상호작용 방식 분류**  
   - 사용자 입력에 “비동기”, “이벤트 기반”, “publish/subscribe” 등이 있으면 **교차 컨텍스트 기본값을 비동기**로 둔다(“연계를 제외한 나머지는 비동기” 같은 조건도 그대로 반영).  
   - 특정 호출이 “동기”, “RPC”, “blocking”이라고 명시된 경우에만 해당 흐름을 동기(즉시 응답)로 취급한다.  
   - 비동기로 분류된 흐름에 Command가 남아 있다면 최종 출력 전에 반드시 Policy로 전환하고, 이름/설명도 비동기 핸들러답게 다듬는다.

6. **JSON 구조화**  
   - `project_name`, `contexts[]`, `connections[]`를 포함하는 단일 JSON 객체를 만든다.

7. **연결(Connections) 생성**  
   - 모든 연결은 `Event`에서 시작해 다른 컨텍스트의 `Command`, `Policy`, 혹은 `ReadModel`을 겨냥한다.
   - 동기/비동기·CQRS 규칙은 아래 객체별 기준을 따른다.

### 객체별 생성 기준

| 객체 | 생성 기준 |
|------|-----------|
| **Bounded Context** | 독립 배포 단위를 그대로 반영. 명확한 책임과 설명을 포함한다. CQRS/읽기 전용 문맥이 언급되면 별도 컨텍스트로 모델링한다. |
| **Aggregate** | 컨텍스트의 핵심 도메인 엔티티. 명사형 이름과 역할 설명 필수. |
| **Command** | 컨텍스트 내부에서 **동기·즉시 실행**되는 작업만 표현. UI/API/RPC 요청처럼 호출 즉시 결과를 기대하는 경우에만 사용한다. 비동기 동작은 Command로 만들지 않는다. |
| **Event** | Command 수행의 결과. 과거 시제 이름과 결과 설명을 포함한다. |
| **Policy** | Event를 비동기로 구독해 후속 동작을 수행하는 리스너. 서비스 간 “비동기 호출” 요구가 있으면 반드시 Policy로 모델링하고, 해당 흐름마다 별도 Policy를 정의한다(예: “민원연계결과수신핸들러”). Policy 명칭/설명에는 “정책/policy”라는 단어를 넣지 말고, 행동을 묘사하는 표현을 사용한다. Policy 설명에는 필요한 경우 “이 핸들러는 내부적으로 XCommand를 호출한다”처럼 후속 동작을 언급할 수 있지만, 교차 컨텍스트 연결선은 항상 `Event -> Policy`여야 한다. |
| **ReadModel (CQRS)** | 사용자 요청에 CQRS/Query/읽기 서비스가 등장하면 해당 컨텍스트에 최소 한 개 이상의 `ReadModel`을 정의한다. 사용자가 언급하지 않아도 `OrderSummaryReadModel`, `ComplaintStatusView`처럼 명확한 이름을 직접 설계하며, 어떤 필드/정보를 제공하는지 `description` 또는 `fields`로 설명한다. |
| **Connections** | `Event`에서 다른 컨텍스트의 `Command`, `Policy`, 혹은 `ReadModel`로 연결. <br>• **동기 호출**: `Event -> Command` <br>• **비동기 호출**: `Event -> Policy` <br>• 사용자가 “전체 비동기”라고 언급하면 예외적으로 명시된 동기 호출을 제외하고 전부 `Event -> Policy`로 생성한다. <br>• **CQRS 호출**: 다른 서비스가 CQRS/ReadModel 컨텍스트를 조회할 때는 Request/Response 패턴으로 간주하여 **직접 `Event -> ReadModel`** 연결을 만들고, 연결의 `type`을 `"RequestResponse"`로 설정해 질의 응답임을 명확히 한다. |

### 적용 팁

- 사용자가 “삭제”, “제거” 등의 요구를 하면 해당 요소를 모델에서 제외하고, 이후 규칙에 맞춰 남은 요소를 다시 구성한다.
- 정책으로 변환해야 할 동작이 Command로 생성되지 않도록, 프롬프트에서는 명시적으로 “비동기 요구가 있으면 반드시 Policy로 표현할 것”을 강조한다.
- Policy 설명에는 필요한 경우 “이 핸들러는 내부적으로 XCommand를 호출한다”처럼 후속 동작을 언급할 수 있다.
- CQRS/ReadModel 컨텍스트를 발견하면 반드시 ReadModel을 정의하고, 다른 서비스가 이를 호출할 때는 Request/Response가 되도록 `Event -> ReadModel` + `type: "RequestResponse"`로 표현한다.
- 기존 보드의 좌표 정보가 제공된 경우, 가능하면 해당 \`x\`/\`y\` 위치를 유지한다. 새 항목을 배치해야 할 때는 가까운 관련 컨텍스트 주변에 배치하되 겹치지 않도록 약간의 오프셋을 준다.

#### 출력 직전 검증 체크리스트

1. 사용자 요청에 “비동기/이벤트 기반”이 있으면 모든 교차 컨텍스트 연결이 `Event -> Policy`인지 다시 확인하고, 남아 있는 Command는 즉시 Policy로 전환한다(예외적으로 명시된 동기 호출만 Command 유지).
2. CQRS/읽기 컨텍스트마다 최소 1개 이상의 ReadModel이 존재하는지 점검한다. 누락 시 즉시 의미 있는 ReadModel을 추가하고 설명/필드 정보를 적는다.
3. ReadModel을 향하는 모든 연결이 `Event -> ReadModel`이며 `type: "RequestResponse"`인지 확인한다.
4. 사용자 요청에 특정 컨텍스트명이 등장했다면 해당 컨텍스트가 실제로 존재하며, 지시된 ReadModel/Policy/Command가 그 컨텍스트 내부에 추가·수정되었는지 확인한다.
5. 좌표가 주어진 보드는 기존 위치를 변경하지 않았는지, 새 항목끼리 겹치지 않는지 확인한다.

